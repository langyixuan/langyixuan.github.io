(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{563:function(e,t,a){"use strict";a.r(t);var s=a(17),v=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"glsl-语法与内建函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#glsl-语法与内建函数"}},[e._v("#")]),e._v(" GLSL 语法与内建函数")]),e._v(" "),a("img",{staticStyle:{zoom:"200%"},attrs:{src:"https://s2.loli.net/2022/07/18/OCM5gRimHfbxew3.jpg",alt:"GLSL"}}),e._v(" "),a("p",[e._v("最近一直对"),a("code",[e._v("Creative Coding")]),e._v(" 部分很感兴趣，也在不断地探索与学习，在学习"),a("code",[e._v("WebGL")]),e._v("部分地时候接触到了"),a("code",[e._v("GLSL")]),e._v("这门美妙且神奇的语言。虽然现在学的还是云里雾里的，但是为了后期方便查询一些 API，在该篇文章中记录一下"),a("code",[e._v("GLSL")]),e._v("的基本语法以及内建函数。")]),e._v(" "),a("p",[a("code",[e._v("GLSL")]),e._v("全称为"),a("code",[e._v("OpenGL Shading Language")]),e._v("，是为了实现着色器的功能而向开发人员提供的一种开发语言，对其只要能理解到这个层次就可以了。")]),e._v(" "),a("blockquote",[a("p",[e._v("每个 shader 只处理一个像素单元")])]),e._v(" "),a("h2",{attrs:{id:"glsl-的修饰符与基本数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#glsl-的修饰符与基本数据类型"}},[e._v("#")]),e._v(" GLSL 的修饰符与基本数据类型")]),e._v(" "),a("h3",{attrs:{id:"🌟-修饰符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🌟-修饰符"}},[e._v("#")]),e._v(" 🌟 修饰符")]),e._v(" "),a("ul",[a("li",[a("p",[a("code",[e._v("const")]),e._v("：用于声明非可写的编译时常量变量。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("attribute")]),e._v("：用于经常更改的信息，只能在顶点着色器中使用。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("uniform")]),e._v("：用于不经常更改的信息，可用于顶点着色器和片元着色器。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("varying")]),e._v("：用于修饰从顶点着色器向片元着色器传递的变量。")]),e._v(" "),a("blockquote",[a("p",[e._v("这个修饰符修饰的变量均用于在"),a("code",[e._v("Vertex Shader")]),e._v("和"),a("code",[e._v("Fragment Shader")]),e._v("之间传递参数。首先在顶点着色器中声明这个类型的变量代表纹理的坐标点，并且对这个变量进行赋值，代码如下：")]),e._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[e._v("attribute vec2 texcoord"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nvarying vec2 v_texcoord"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 计算顶点坐标")]),e._v("\n    v_texcoord "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" texcoord"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("紧接着在"),a("code",[e._v("Fragment Shader")]),e._v("中也声明同名的变量，然后使用"),a("code",[e._v("texture2D")]),e._v("方法取出二维纹理中该纹理坐标点上的纹理像素值，代码如下（GLSL 代码）：")]),e._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[e._v("varying vec2 v_texcoord"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nvec4 texel "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("texture2D")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("texSampler"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" v_texcoord"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[e._v("取出了该坐标点上的像素值之后，就可以进行像素变化操作了，比如说提高对比度，最终将改变的像素值赋值给"),a("code",[e._v("gl_FragColor")]),e._v("。")])])])]),e._v(" "),a("h3",{attrs:{id:"🌟-基本数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🌟-基本数据类型"}},[e._v("#")]),e._v(" 🌟 基本数据类型")]),e._v(" "),a("p",[a("code",[e._v("int")]),e._v("、"),a("code",[e._v("float")]),e._v("、"),a("code",[e._v("bool")]),e._v("，这些与 C 语言都是一致的，需要强调的一点就是，这里面的 float 是有一个修饰符的，即可以指定精度。三种修饰符的范围（范围一般视显卡而定）和应用情况具体如下。")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("highp")]),e._v(":32bit，一般用于顶点坐标（vertex Coordinate）。")]),e._v(" "),a("li",[a("code",[e._v("medium")]),e._v(":16bit，一般用于纹理坐标（texture Coordinate）。")]),e._v(" "),a("li",[a("code",[e._v("lowp")]),e._v(":8bit，一般用于颜色表示（color）。")])]),e._v(" "),a("h4",{attrs:{id:"👉-向量类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#👉-向量类型"}},[e._v("#")]),e._v(" 👉 向量类型")]),e._v(" "),a("p",[a("code",[e._v("向量类型")]),e._v("是 Shader 中非常重要的一个数据类型，在做数据传递的时候需要经常传递多个参数，相较于写多个基本数据类型，使用向量类型是非常好的选择")]),e._v(" "),a("p",[e._v("声明方式如下（GLSL 代码）：")]),e._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[e._v("attribute vec4 position"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//vec4表示四维向量")]),e._v("\n")])])]),a("h4",{attrs:{id:"矩阵类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#矩阵类型"}},[e._v("#")]),e._v(" 矩阵类型")]),e._v(" "),a("p",[a("code",[e._v("矩阵类型")]),e._v("在 Shader 的语法中也是一个非常重要的类型，有一些效果器需要开发者传入矩阵类型的数据，比如后面会接触到的怀旧效果器，就需要传入一个矩阵来改变原始的像素数据。声明方式如下（GLSL 代码）：")]),e._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[e._v("uniform lowp mat4 colorMatrix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//mat4表示4x4的浮点矩阵")]),e._v("\n")])])]),a("h4",{attrs:{id:"纹理类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#纹理类型"}},[e._v("#")]),e._v(" 纹理类型")]),e._v(" "),a("p",[e._v("一般仅在 Fragment Shader 中使用这个类型，二维纹理的声明方式如下（GLSL 代码）：")]),e._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[e._v("uniform sampler2D texSampler；\n")])])]),a("blockquote",[a("p",[e._v("当客户端接收到这个句柄时，就可以为它绑定一个纹理，代码如下（客户端代码）： glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, texId); glUniform1i(mGLUniformTexture, 0); 注意上述代码中第一行激活的是哪一个纹理句柄，第三行代码中的第二个参数需要传递对应的 Index，就像代码中激活的纹理句柄是 GL_TEXTURE0，对应的 Index 就是 0，如果激活的纹理句柄是 GL_TEXTURE1，那么对应的 Index 就是 1")])]),e._v(" "),a("h2",{attrs:{id:"二、glsl-的内置函数与内置变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、glsl-的内置函数与内置变量"}},[e._v("#")]),e._v(" 二、GLSL 的内置函数与内置变量")]),e._v(" "),a("h3",{attrs:{id:"🌟-内置变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🌟-内置变量"}},[e._v("#")]),e._v(" 🌟 内置变量")]),e._v(" "),a("h4",{attrs:{id:"vertex-shader-的内置变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vertex-shader-的内置变量"}},[e._v("#")]),e._v(" Vertex Shader 的内置变量：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("vec4 gl_position")]),e._v("：用来设置顶点转换到屏幕坐标的位置，Vertex Shader 一定要去更新这个数值。")]),e._v(" "),a("li",[a("code",[e._v("float gl_pointSize")]),e._v("：在粒子效果的场景下，需要为粒子设置大小，改变该内置变量的值就是为了设置每一个粒子矩形的大小。")])]),e._v(" "),a("h4",{attrs:{id:"fragment-shader-的内置变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fragment-shader-的内置变量"}},[e._v("#")]),e._v(" Fragment Shader 的内置变量：")]),e._v(" "),a("p",[a("code",[e._v("vec4 gl_FragColor")]),e._v("：用于指定当前纹理坐标所代表的像素点的最终颜色值。")]),e._v(" "),a("h3",{attrs:{id:"🌟-内置函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🌟-内置函数"}},[e._v("#")]),e._v(" 🌟 内置函数")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("abs(genType x)")]),e._v("：绝对值函数。")]),e._v(" "),a("li",[a("code",[e._v("floor(genType x)")]),e._v("：向下取整函数。")]),e._v(" "),a("li",[a("code",[e._v("ceil(genType x)")]),e._v("：向上取整函数。")]),e._v(" "),a("li",[a("code",[e._v("mod(genType x, genType y)")]),e._v("：取模函数。")]),e._v(" "),a("li",[a("code",[e._v("min(genType x, genType y)")]),e._v("：取得最小值函数。")]),e._v(" "),a("li",[a("code",[e._v("max(genType x, genType y)")]),e._v("：取得最大值函数。")]),e._v(" "),a("li",[a("code",[e._v("clamp(genType x, genType y, genType z)")]),e._v("：取得中间值函数。")]),e._v(" "),a("li",[a("code",[e._v("step(genType edge, genType x)")]),e._v("：如果 x < edge，则返回 0.0，否则返回 1.0。")]),e._v(" "),a("li",[a("code",[e._v("smoothstep(genType edge0, genType edge1, genType x)")]),e._v("：如果 x≤edge0，则返回 0.0；如果 x≥edge1，则返回 1.0；如果 edge0 < x < edge1，则执行 0 ～ 1 之间的平滑差值。")]),e._v(" "),a("li",[a("code",[e._v("mix(genType x, genType y, genType a)")]),e._v("：返回线性混合的 x 和 y，用公式表示为：x*(1-a)+y*a，这个函数在 mix 两个纹理图像的时候非常有用。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);